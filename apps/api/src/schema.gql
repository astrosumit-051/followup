# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

"""
Contact GraphQL Entity

Represents a contact in the GraphQL schema with all fields
matching the Prisma Contact model.

Security:
- userId is hidden from GraphQL schema to prevent information leakage
- Only accessible internally for authorization checks
"""
type Contact {
  birthday: DateTime
  company: String
  createdAt: DateTime!
  email: String
  gender: Gender
  id: ID!
  industry: String
  lastContactedAt: DateTime
  linkedInUrl: String
  name: String!
  notes: String
  phone: String
  priority: Priority!
  profilePicture: String
  role: String
  updatedAt: DateTime!
}

"""
ContactConnection GraphQL Entity

Represents a paginated list of contacts following the Relay
connection specification for cursor-based pagination.

This structure provides:
- nodes: Array of Contact objects for easy access
- edges: Array of ContactEdge for cursor-based navigation
- pageInfo: Metadata about pagination state
- totalCount: Total number of contacts matching the query
"""
type ContactConnection {
  edges: [ContactEdge!]!
  nodes: [Contact!]!
  pageInfo: PageInfo!
  totalCount: Int!
}

"""
ContactEdge GraphQL Entity

Represents an edge in a connection, containing a node and a cursor.
Used for cursor-based pagination.
"""
type ContactEdge {
  cursor: String!
  node: Contact!
}

"""
DTO for filtering contacts in list queries

All fields are optional and can be combined for precise filtering.
Multiple filters are combined with AND logic.
"""
input ContactFilterInput {
  company: String
  industry: String
  priority: Priority
  role: String
  search: String
}

"""
DTO for cursor-based pagination

Implements cursor-based pagination for efficient scrolling through large contact lists.
- cursor: UUID cursor pointing to a position in the result set
- limit: Number of results per page (default: 20, max: 100)
"""
input ContactPaginationInput {
  cursor: String
  limit: Int = 20
}

"""Fields available for sorting contacts"""
enum ContactSortField {
  COMPANY
  CREATED_AT
  INDUSTRY
  LAST_CONTACTED_AT
  NAME
  PRIORITY
}

"""
Conversation History Entity

Represents a single entry in the conversation history between user and contact.
Used to provide context to AI for personalized email generation.
"""
type ConversationHistory {
  contactId: String!
  content: String!
  direction: Direction!
  emailId: String
  id: ID!
  metadata: JSONObject
  timestamp: DateTime!
}

"""
DTO for creating a new contact

Validation rules:
- name: Required, 1-255 characters
- email: Optional, valid email format
- phone: Optional, max 50 characters
- linkedInUrl: Optional, valid URL format
- company: Optional, max 255 characters
- industry: Optional, max 255 characters
- role: Optional, max 255 characters
- priority: Optional, valid Priority enum (defaults to MEDIUM in service layer)
- gender: Optional, valid Gender enum
- birthday: Optional, valid Date
- notes: Optional, max 10,000 characters
"""
input CreateContactDto {
  birthday: DateTime
  company: String
  email: String
  gender: Gender
  industry: String
  linkedInUrl: String
  name: String!
  notes: String
  phone: String
  priority: Priority
  role: String
}

"""
Input for Creating a Conversation History Entry

Used to track conversation history between user and contact.
Automatically created when emails are sent.
"""
input CreateConversationEntryInput {
  contactId: String!
  content: String!
  direction: Direction!
  emailId: String
  metadata: JSONObject
}

"""
Input for Creating Email Draft

Used to create a new email draft for a specific contact.
Minimal required fields - most content is added via auto-save updates.
"""
input CreateDraftInput {
  """Array of attachment metadata (optional)"""
  attachments: [JSON!]

  """Pre-rendered HTML body (optional)"""
  bodyHtml: String

  """TipTap document JSON for rich text body (optional)"""
  bodyJson: JSON

  """ID of the contact this draft is addressed to"""
  contactId: String!

  """ID of the email signature to use (optional)"""
  signatureId: String

  """Email subject line (optional)"""
  subject: String
}

"""
Input for Creating an Email Template

Used to save reusable email templates with custom names and categories.
Templates can be marked as default for quick access.
"""
input CreateEmailTemplateInput {
  body: String!
  bodyHtml: String
  category: String
  isDefault: Boolean
  name: String!
  subject: String!
}

"""
Input for Creating Email Signature

Used to create new email signatures with rich text content (TipTap JSON).
Users can set default flags for automatic signature selection.
"""
input CreateSignatureInput {
  """Pre-rendered HTML for email sending"""
  contentHtml: String!

  """TipTap document JSON format for rich text editing"""
  contentJson: JSON!

  """Set as default for casual emails"""
  isDefaultForCasual: Boolean = false

  """Set as default for formal emails"""
  isDefaultForFormal: Boolean = false

  """Set as global fallback default"""
  isGlobalDefault: Boolean = false

  """User-friendly name for this signature (e.g., "Professional", "Casual")"""
  name: String!
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

"""Direction of conversation (SENT by user or RECEIVED from contact)"""
enum Direction {
  RECEIVED
  SENT
}

"""
An email generated by AI or manually created by the user. Can be a draft, scheduled, or sent email.
"""
type Email {
  """Plain text email body (50-2000 characters)"""
  body: String!

  """HTML-formatted email body (optional)"""
  bodyHtml: String

  """ID of the contact this email is addressed to"""
  contactId: String!

  """Timestamp when email record was created"""
  createdAt: DateTime!

  """Timestamp when email was generated by AI"""
  generatedAt: DateTime

  """Unique identifier for this email"""
  id: ID!

  """Timestamp when recipient opened the email (via tracking pixel)"""
  openedAt: DateTime

  """LLM provider that generated this email (gemini, openai, anthropic)"""
  providerId: String

  """Timestamp when recipient replied to the email"""
  repliedAt: DateTime

  """Timestamp when email was sent to recipient"""
  sentAt: DateTime

  """Current state of the email (DRAFT, SENT, SCHEDULED, FAILED, CANCELLED)"""
  status: EmailStatus!

  """Email subject line (5-200 characters)"""
  subject: String!

  """
  Style variant used (FORMAL, CASUAL, CUSTOM, AI_GENERATED, TEMPLATE_BASED)
  """
  templateType: TemplateType

  """Number of tokens used during AI generation (for cost tracking)"""
  tokensUsed: Int

  """Timestamp when email record was last modified"""
  updatedAt: DateTime!
}

"""
EmailConnection GraphQL Entity

Represents a paginated list of emails using offset-based pagination.

This structure provides:
- emails: Array of Email objects
- pageInfo: Metadata about pagination state and total count
"""
type EmailConnection {
  emails: [Email!]!
  pageInfo: EmailPageInfo!
}

"""
An auto-saved email draft with rich text content stored in TipTap JSON format. One draft per user-contact pair.
"""
type EmailDraft {
  """
  Array of attachment metadata (S3 keys, filenames, sizes, content types)
  """
  attachments: [JSON!]!

  """Pre-rendered HTML for sending (optional)"""
  bodyHtml: String

  """TipTap document JSON format for rich text editing"""
  bodyJson: JSON!

  """ID of the contact this draft is addressed to"""
  contactId: ID!

  """Timestamp when draft was created"""
  createdAt: DateTime!

  """Unique identifier for this draft"""
  id: ID!

  """Timestamp of last DB sync from localStorage (for conflict detection)"""
  lastSyncedAt: DateTime

  """ID of the email signature to use (optional)"""
  signatureId: ID

  """Email subject line (optional, can be empty)"""
  subject: String

  """Timestamp when draft was last modified"""
  updatedAt: DateTime!

  """ID of the user who owns this draft"""
  userId: ID!
}

type EmailDraftConnection {
  """Array of email drafts in this page"""
  edges: [EmailDraft!]!

  """Pagination metadata (hasNextPage, total)"""
  pageInfo: EmailDraftPageInfo!
}

type EmailDraftPageInfo {
  """Whether there are more results available"""
  hasNextPage: Boolean!

  """Total number of items matching the query"""
  total: Int!
}

"""
PageInfo GraphQL Entity

Contains pagination metadata for offset-based pagination.
Provides information about whether more results are available.
"""
type EmailPageInfo {
  hasMore: Boolean!
  skip: Int!
  take: Int!
  total: Int!
}

"""
A reusable email signature with rich text formatting. Users can have multiple signatures with context-based default selection.
"""
type EmailSignature {
  """Pre-rendered HTML for email sending"""
  contentHtml: String!

  """TipTap document JSON format for rich text editing"""
  contentJson: JSON!

  """Timestamp when signature was created"""
  createdAt: DateTime!

  """Unique identifier for this signature"""
  id: ID!

  """Whether this signature is the default for casual emails"""
  isDefaultForCasual: Boolean!

  """Whether this signature is the default for formal emails"""
  isDefaultForFormal: Boolean!

  """Whether this signature is the global fallback default"""
  isGlobalDefault: Boolean!

  """
  User-friendly name for this signature (e.g., "Formal", "Casual", "Sales Pitch")
  """
  name: String!

  """Timestamp when signature was last modified"""
  updatedAt: DateTime!

  """Number of times this signature has been used (for analytics)"""
  usageCount: Int!

  """ID of the user who owns this signature"""
  userId: ID!
}

"""Current state of an email (DRAFT, SCHEDULED, SENT, FAILED, CANCELLED)"""
enum EmailStatus {
  CANCELLED
  DRAFT
  FAILED
  SCHEDULED
  SENT
}

"""
Email Template Entity

Represents a saved email template that users can reuse for similar communications.
Tracks usage count and allows marking a default template.
"""
type EmailTemplate {
  body: String!
  bodyHtml: String
  category: String
  createdAt: DateTime!
  id: ID!
  isDefault: Boolean!
  name: String!
  subject: String!
  updatedAt: DateTime!
  usageCount: Int!
}

"""A single style variant of a generated email (formal or casual)"""
type EmailVariant {
  """Generated email body text (50-300 words)"""
  body: String!

  """HTML-formatted email body (optional, for rich formatting)"""
  bodyHtml: String

  """Generated email subject line (5-50 words)"""
  subject: String!
}

"""
Input for Finding/Filtering Emails

Supports pagination, filtering by contact and status.
Used by the emails query to list user's emails with filters.
"""
input FindEmailsInput {
  contactId: String
  skip: Int
  status: EmailStatus
  take: Int
}

"""Contact gender options"""
enum Gender {
  FEMALE
  MALE
  OTHER
  PREFER_NOT_TO_SAY
}

"""
Input for AI Email Template Generation

Used to generate personalized email templates (formal and casual variants)
based on contact context and conversation history.
"""
input GenerateEmailInput {
  additionalContext: String
  contactId: String!
  includeConversationHistory: Boolean
}

"""AI-generated email template with both formal and casual style variants"""
type GeneratedEmailTemplate {
  """
  Casual communication style: friendly, conversational, warm yet professional
  """
  casual: EmailVariant!

  """ID of the contact this template was generated for"""
  contactId: String!

  """
  Formal communication style: professional, structured, suitable for business networking
  """
  formal: EmailVariant!

  """Timestamp when template was generated"""
  generatedAt: DateTime!

  """LLM provider that generated this template (gemini, openai, anthropic)"""
  providerId: String!

  """
  Total tokens used during generation (for cost tracking across both variants)
  """
  tokensUsed: Int!
}

"""
Gmail OAuth connection status for a user. Tokens are never exposed for security.
"""
type GmailConnection {
  """Timestamp when Gmail was connected (null if not connected)"""
  connectedAt: DateTime

  """Connected Gmail email address (null if not connected)"""
  email: String

  """Timestamp when access token expires (null if not connected)"""
  expiresAt: DateTime

  """Whether user has an active Gmail connection with valid tokens"""
  isConnected: Boolean!

  """OAuth scopes granted (e.g., ["gmail.send", "gmail.readonly"])"""
  scopes: [String!]!
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

"""
The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSONObject

type Mutation {
  autoSaveDraft(input: CreateDraftInput!): EmailDraft!
  createContact(input: CreateContactDto!): Contact!
  createConversationEntry(input: CreateConversationEntryInput!): ConversationHistory!
  createEmailTemplate(input: CreateEmailTemplateInput!): EmailTemplate!
  createSignature(input: CreateSignatureInput!): EmailSignature!
  deleteContact(id: ID!): Boolean!
  deleteDraft(contactId: ID!): Boolean!
  deleteEmail(id: ID!): Boolean!
  deleteEmailTemplate(id: ID!): Boolean!
  deleteSignature(id: ID!): Boolean!
  generateEmailTemplate(input: GenerateEmailInput!): GeneratedEmailTemplate!
  saveEmail(input: SaveEmailInput!): Email!
  updateContact(id: ID!, input: UpdateContactDto!): Contact!
  updateEmail(input: UpdateEmailInput!): Email!
  updateEmailTemplate(id: ID!, input: UpdateEmailTemplateInput!): EmailTemplate!
  updateProfile(updateProfileDto: UpdateProfileDto!): String!
  updateSignature(id: ID!, input: UpdateSignatureInput!): EmailSignature!
}

"""
PageInfo GraphQL Entity

Contains pagination metadata for cursor-based pagination.
Follows Relay specification for connection-based pagination.
"""
type PageInfo {
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
}

"""
Pagination Input

Used for paginating list results with skip/take pattern.
"""
input PaginationInput {
  """Number of items to skip (default: 0)"""
  skip: Int = 0

  """Number of items to take (default: 10, max: 100)"""
  take: Int = 10
}

"""Contact priority levels"""
enum Priority {
  HIGH
  LOW
  MEDIUM
}

type Query {
  contact(id: ID!): Contact
  contacts(filters: ContactFilterInput, pagination: ContactPaginationInput, sortBy: ContactSortField = CREATED_AT, sortOrder: String = "desc"): ContactConnection!
  conversationHistory(contactId: ID!, limit: Float = 5): [ConversationHistory!]!
  email(id: ID!): Email!
  emailDraft(contactId: ID!): EmailDraft
  emailDrafts(pagination: PaginationInput): EmailDraftConnection!
  emailSignatures: [EmailSignature!]!
  emailTemplates: [EmailTemplate!]!
  emails(input: FindEmailsInput): EmailConnection!
  gmailConnection: GmailConnection!
  me: String!
}

"""
Input for Saving an Email

Used to save AI-generated or manually composed emails to the database.
Emails are created with DRAFT status by default unless specified.
"""
input SaveEmailInput {
  body: String!
  bodyHtml: String
  contactId: String!
  providerId: String
  status: EmailStatus
  subject: String!
  templateType: TemplateType
  tokensUsed: Float
}

"""
Style/source of email template (FORMAL, CASUAL, CUSTOM, AI_GENERATED, TEMPLATE_BASED)
"""
enum TemplateType {
  AI_GENERATED
  CASUAL
  CUSTOM
  FORMAL
  TEMPLATE_BASED
}

"""
DTO for updating an existing contact

All fields are optional to allow partial updates.
Only provided fields will be validated and updated.

All validation rules from CreateContactDto apply when fields are provided.
Immutable fields (id, userId, createdAt) cannot be updated.
"""
input UpdateContactDto {
  birthday: DateTime
  company: String
  email: String
  gender: Gender
  industry: String
  linkedInUrl: String
  name: String
  notes: String
  phone: String
  priority: Priority
  role: String
}

"""
Input for Updating an Email

Used to update draft emails. Only draft emails can be updated.
All fields except id are optional to allow partial updates.
"""
input UpdateEmailInput {
  body: String
  bodyHtml: String
  id: ID!
  status: EmailStatus
  subject: String
  templateType: TemplateType
}

"""
Input for Updating an Email Template

All fields are optional to allow partial updates.
Only provided fields will be validated and updated.
"""
input UpdateEmailTemplateInput {
  body: String
  bodyHtml: String
  category: String
  isDefault: Boolean
  name: String
  subject: String
}

"""
Data Transfer Object for updating user profile

Security Features:
- Input length validation (prevents buffer overflow attacks)
- Character set validation (prevents XSS and injection attacks)
- URL format validation (prevents malicious URL injections)
- Optional fields (provides flexibility)
"""
input UpdateProfileDto {
  """
  User's display name
  
  Validation Rules:
  - Optional field
  - Must be a string
  - Min length: 1 character (no empty strings)
  - Max length: 100 characters (prevent buffer overflow)
  - Allowed characters: Unicode letters, numbers, spaces, hyphens, apostrophes, periods
  - Prevents: XSS attacks, SQL injection, control characters
  
  Supports international names including:
  - Latin: John Doe, María García, François Müller
  - Cyrillic: Иван Петров, Ольга Смирнова
  - Arabic: محمد علي, فاطمة حسن
  - Chinese: 李明, 王芳
  - Japanese: 田中太郎, さくら
  - Korean: 김철수, 이영희
  """
  name: String

  """
  URL to user's profile picture
  
  Validation Rules:
  - Optional field
  - Must be a valid URL format
  - Must use HTTPS protocol (prevents mixed content attacks)
  - Max length: 2048 characters (standard URL length limit)
  - Prevents: Protocol injection, XSS attacks, file:// URIs
  """
  profilePicture: String
}

"""
Input for Updating Email Signature

Used to update existing email signatures. All fields are optional.
Setting a default flag will automatically unset other signatures with the same flag.
"""
input UpdateSignatureInput {
  """Updated pre-rendered HTML"""
  contentHtml: String

  """Updated TipTap document JSON"""
  contentJson: JSON

  """Update casual default flag"""
  isDefaultForCasual: Boolean

  """Update formal default flag"""
  isDefaultForFormal: Boolean

  """Update global default flag"""
  isGlobalDefault: Boolean

  """Updated name for this signature"""
  name: String
}